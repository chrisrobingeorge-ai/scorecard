# overall_scorecard_app.py
#
# Purpose:
#   Take the department scorecard PDFs from the Monthly Scorecard app,
#   extract their embedded JSON, and generate an organisation-wide
#   Board narrative + PDF.
#
#   This app:
#   - Shows a simple table of which departments/months you’ve loaded
#   - Calls ai_utils.interpret_overall_scorecards(...) for the AI summary
#   - Lets you EDIT the AI text before exporting
#   - Uses pdf_utils.build_overall_board_pdf(...) to create a Board PDF

from __future__ import annotations

import json
from typing import Dict, Any, List

import pandas as pd
import streamlit as st
from PyPDF2 import PdfReader

from ai_utils import interpret_overall_scorecards
from pdf_utils import build_overall_board_pdf

JSON_PREFIX = "AB_SCORECARD_JSON:"

# ─────────────────────────────────────────────────────────────────────────────
# Streamlit page config
# ─────────────────────────────────────────────────────────────────────────────
st.set_page_config(page_title="Overall Monthly Scorecard – Board Report", layout="wide")

st.title("Overall Monthly Scorecard – Board Narrative")

st.write(
    """
Upload the **department scorecard PDFs** generated by the Monthly Scorecard app.  
This helper will extract their embedded summaries and generate a single,
organisation-wide Board report (and a downloadable PDF).
"""
)

# ─────────────────────────────────────────────────────────────────────────────
# Helper: extract a structured summary from one payload
# ─────────────────────────────────────────────────────────────────────────────
def extract_department_summary(
    payload: Dict[str, Any],
    source_name: str,
) -> Dict[str, Any]:
    """
    Take the JSON payload embedded in a scorecard PDF and distill the
    key bits we need for an organisation-wide narrative.
    """
    meta = payload.get("meta", {}) or {}
    scores = payload.get("scores", {}) or {}
    ai_interp = payload.get("ai_interpretation", {}) or {}
    questions = payload.get("questions", []) or []

    department = meta.get("department") or meta.get("dept_label") or ""
    month = meta.get("month")
    month_label = meta.get("month_label") or month
    production = meta.get("production") or meta.get("programme") or ""
    staff_name = meta.get("staff_name") or ""
    role = meta.get("role") or ""

    overall_score = scores.get("overall_score")
    pillar_scores = scores.get("pillar_scores") or {}

    summary_text = ai_interp.get("overall_summary") or ""

    return {
        "source_file": source_name,
        "department": department,
        "month": month,
        "month_label": month_label,
        "overall_score": overall_score,
        "pillar_scores": pillar_scores,
        "production": production,
        "staff_name": staff_name,
        "role": role,
        "num_questions": len(questions),
        "summary_text": summary_text,
    }


# ─────────────────────────────────────────────────────────────────────────────
# 1. Upload PDFs
# ─────────────────────────────────────────────────────────────────────────────
uploaded_files = st.file_uploader(
    "Upload department scorecard PDFs (you can select multiple)",
    type=["pdf"],
    accept_multiple_files=True,
)

if not uploaded_files:
    st.stop()

# ─────────────────────────────────────────────────────────────────────────────
# 2. Extract JSON from each PDF and build department summaries
# ─────────────────────────────────────────────────────────────────────────────
dept_summaries: List[Dict[str, Any]] = []
skipped_files: List[str] = []

for f in uploaded_files:
    try:
        reader = PdfReader(f)
    except Exception:
        skipped_files.append(f.name)
        continue

    info = reader.metadata or {}
    subject = getattr(info, "subject", None) or info.get("/Subject") or ""

    if not subject or JSON_PREFIX not in subject:
        skipped_files.append(f.name)
        continue

    try:
        _, json_str = subject.split(JSON_PREFIX, 1)
        payload = json.loads(json_str)
    except Exception:
        skipped_files.append(f.name)
        continue

    dept_summary = extract_department_summary(payload, f.name)
    dept_summaries.append(dept_summary)

if not dept_summaries:
    st.error("No usable embedded scorecard data found in the uploaded PDFs.")
    if skipped_files:
        st.info("Files skipped (no or invalid embedded JSON): " + ", ".join(skipped_files))
    st.stop()

if skipped_files:
    st.warning(
        "Some files were skipped because they did not contain embedded scorecard data: "
        + ", ".join(skipped_files)
    )

# ─────────────────────────────────────────────────────────────────────────────
# 3. Sanity table – what did we load?
# ─────────────────────────────────────────────────────────────────────────────
df_overview = pd.DataFrame(
    [
        {
            "source_file": ds["source_file"],
            "department": ds["department"],
            "month_label": ds["month_label"],
            "overall_score": ds["overall_score"],
            "num_questions": ds["num_questions"],
        }
        for ds in dept_summaries
    ]
)

st.subheader("Loaded department scorecards")
st.dataframe(df_overview, use_container_width=True)

# Infer a reporting label (e.g., a single month, or multiple)
unique_months = df_overview["month_label"].dropna().unique().tolist()
if len(unique_months) == 1:
    reporting_label = unique_months[0]
elif len(unique_months) > 1:
    reporting_label = ", ".join(unique_months)
else:
    reporting_label = "Multiple periods"

st.markdown(f"**Reporting period (inferred):** {reporting_label}")

# ─────────────────────────────────────────────────────────────────────────────
# 4. Board-level AI Interpretation (fully editable)
# ─────────────────────────────────────────────────────────────────────────────
st.subheader("Board Interpretation (editable)")

# Initialise cached AI result for the overall Board report
if "overall_ai_result" not in st.session_state:
    st.session_state["overall_ai_result"] = None

# Helper normalisers (parallel to main app, but simplified for Board layer)
def _normalise_overall(val: Any) -> str:
    """Turn overall_summary (string / list / dict) into a single editable string."""
    if isinstance(val, list):
        parts = []
        for v in val:
            if isinstance(v, dict) and "text" in v:
                parts.append(str(v["text"]))
            else:
                parts.append(str(v))
        return "\n\n".join(p for p in parts if str(p).strip())
    if isinstance(val, dict) and "text" in val:
        return str(val["text"])
    return str(val or "")

def _normalise_list(val: Any) -> str:
    """Turn list-like fields (risks, priorities) into newline-separated text."""
    if not val:
        return ""
    if isinstance(val, list):
        return "\n".join(str(x) for x in val if str(x).strip())
    return str(val or "")

# Button to (re)generate the Board-level AI interpretation
if st.button("Generate / Refresh Board Narrative with AI"):
    try:
        with st.spinner("Generating Board-level narrative from departmental summaries..."):
            ai_result = interpret_overall_scorecards(dept_summaries)
    except RuntimeError as e:
        st.error(f"AI configuration error: {e}")
        st.info(
            "Check your OPENAI_API_KEY secret and that `openai>=1.51.0` "
            "(or newer) is in requirements.txt."
        )
        st.stop()
    except Exception as e:
        st.error(f"Failed to generate Board report: {e}")
        st.stop()

    st.success("Board-level AI report generated.")
    st.session_state["overall_ai_result"] = ai_result

overall_ai_result = st.session_state["overall_ai_result"]

if overall_ai_result is None:
    st.info("Click **Generate / Refresh Board Narrative with AI** to create the report.")
else:
    ai_result = overall_ai_result  # local alias for easier mutation

    # ── Executive Summary / Board narrative (editable) ─────────────────────
    raw_overall = ai_result.get("overall_summary", "")
    default_overall = _normalise_overall(raw_overall)

    st.markdown("### Draft Board Report")

    edited_overall = st.text_area(
        "Board report narrative (this version will appear in the PDF):",
        value=default_overall,
        height=260,
        key="board_overall_summary_editor",
    )
    ai_result["overall_summary"] = edited_overall

    # ── Strategic Pillars (editable) ───────────────────────────────────────
    pillar_summaries = ai_result.get("pillar_summaries", []) or []
    st.markdown("### Strategic Pillars")

    if pillar_summaries:
        for i, ps in enumerate(pillar_summaries):
            pillar_label = ps.get("strategic_pillar", "Pillar") or "Pillar"
            summary_val = str(ps.get("summary", "") or "")

            st.markdown(f"#### Pillar {i+1}: {pillar_label}")

            new_pillar_label = st.text_input(
                f"Pillar name (Pillar {i+1})",
                value=pillar_label,
                key=f"board_pillar_name_{i}",
            )
            new_summary = st.text_area(
                f"Pillar narrative (Pillar {i+1})",
                value=summary_val,
                height=140,
                key=f"board_pillar_summary_{i}",
            )

            ps["strategic_pillar"] = new_pillar_label
            ps["summary"] = new_summary

    # ── Risks (editable) ───────────────────────────────────────────────────
    risks_raw = ai_result.get("risks", []) or []
    risks_default = _normalise_list(risks_raw)

    st.markdown("### Strategic Pillar Risks / Concerns")
    risks_edited = st.text_area(
        "One risk / area to watch per line:",
        value=risks_default,
        height=140,
        key="board_risks_editor",
    )
    ai_result["risks"] = [
        line.strip() for line in risks_edited.splitlines() if line.strip()
    ]

    # ── Organisation-wide Priorities (editable) ────────────────────────────
    priorities_raw = ai_result.get("priorities_next_month", []) or []
    priorities_default = _normalise_list(priorities_raw)

    st.markdown("### Organisation-wide Priorities for Next Period")
    priorities_edited = st.text_area(
        "One priority per line:",
        value=priorities_default,
        height=140,
        key="board_priorities_editor",
    )
    ai_result["priorities_next_month"] = [
        line.strip() for line in priorities_edited.splitlines() if line.strip()
    ]

    # ── Notes for Leadership (editable) ────────────────────────────────────
    nfl_raw = ai_result.get("notes_for_leadership", "") or ""
    nfl_default = str(nfl_raw)

    st.markdown("### Notes for Leadership")
    nfl_edited = st.text_area(
        "Notes for Leadership (this will appear as prose in the PDF):",
        value=nfl_default,
        height=160,
        key="board_notes_for_leadership_editor",
    )
    ai_result["notes_for_leadership"] = nfl_edited

    # Persist the edited result back to session_state
    st.session_state["overall_ai_result"] = ai_result

    # Optional: show the underlying AI prompt (from interpret_overall_scorecards)
    prompt_used = ai_result.get("prompt", "")
    if prompt_used:
        with st.expander("Show AI prompt used", expanded=False):
            st.code(prompt_used, language="markdown")

    # ─────────────────────────────────────────────────────────────────────
    # 5. Build and download the Board PDF
    # ─────────────────────────────────────────────────────────────────────
    st.subheader("Export Board Report")

    pdf_bytes = build_overall_board_pdf(
        reporting_label=reporting_label,
        dept_overview=df_overview,
        ai_result=ai_result,
        logo_path="assets/alberta_ballet_logo.png",  # adjust if needed
    )

    st.download_button(
        label="Download Board Report PDF",
        data=pdf_bytes,
        file_name=f"overall_board_report_{reporting_label.replace(' ', '_')}.pdf",
        mime="application/pdf",
    )
